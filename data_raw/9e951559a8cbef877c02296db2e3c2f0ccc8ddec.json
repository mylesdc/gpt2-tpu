{
    "paper_id": "9e951559a8cbef877c02296db2e3c2f0ccc8ddec",
    "metadata": {
        "title": "Structural Complexity of DNA Sequence",
        "authors": [
            {
                "first": "Cheng-Yuan",
                "middle": [],
                "last": "Liou",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Taiwan University",
                    "location": {
                        "postCode": "10617",
                        "settlement": "Taipei",
                        "country": "Taiwan"
                    }
                },
                "email": "cyliou@csie.ntu.edu.tw"
            },
            {
                "first": "Shen-Han",
                "middle": [],
                "last": "Tseng",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Taiwan University",
                    "location": {
                        "postCode": "10617",
                        "settlement": "Taipei",
                        "country": "Taiwan"
                    }
                },
                "email": ""
            },
            {
                "first": "Wei-Chen",
                "middle": [],
                "last": "Cheng",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Taiwan University",
                    "location": {
                        "postCode": "10617",
                        "settlement": "Taipei",
                        "country": "Taiwan"
                    }
                },
                "email": ""
            },
            {
                "first": "Huai-Ying",
                "middle": [],
                "last": "Tsai",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Taiwan University",
                    "location": {
                        "postCode": "10617",
                        "settlement": "Taipei",
                        "country": "Taiwan"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "In modern bioinformatics, finding an efficient way to allocate sequence fragments with biological functions is an important issue. This paper presents a structural approach based on context-free grammars extracted from original DNA or protein sequences. This approach is radically different from all those statistical methods. Furthermore, this approach is compared with a topological entropy-based method for consistency and difference of the complexity results.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "DNA sequence analysis becomes important part in modern molecular biology. DNA sequence is composed of four nucleotide bases-adenine (abbreviated A), cytosine (C), guanine (G), and thymine (T) in any order. With four different nucleotides, 2 nucleotides could only code for maximum of 4 2 amino acids, but 3 nucleotides could code for a maximum 4 3 amino acids. George Gamow was the first person to postulate that every three bases can translate to a single amino acid, called a codon. Marshall Nirenberg and Heinrich J. Matthaei were the first to elucidate the nature of a genetic code. A short DNA sequence can contain less genetic information, while lots of bases may contain much more genetic information, and any two nucleotides switch place may change the meaning of genetic messages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Sequence arrangement can produce many different results, but only few codons exist in living bodies. Some sequences do not contain any information which is known as junk DNA. Finding an efficient way to analyze a sequence fragment corresponding to genetic functions is also a challenging problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In recent papers, methods broadly fall into two categories, sequence complexity [1, 2] and structural pattern analysis [3] [4] [5] [6] [7] [8] . Koslicki [1] presented a method for computing sequence complexities. He redefined topological entropy function so that the complexity value will not converge toward zero for much longer sequences. With separate sequence into several segments, it can determine the segments where are exons or introns, and meaningful or meaningless. Hao et al. [7] given a graphical representation of DNA sequence, according to this paper, we can find some rare occurred subsequences. R. Zhang and C. T. Zhang [4] used four-nucleotide-related function drawing 3D curves graph to analyze the number of four-nucleotide occurrence probabilities. Liou et al. [9] had given a new idea in modeling complexity for music rhythms; this paper translated text messages into computable values, so computers can score for music rhythms.",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 83,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 84,
                    "end": 86,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 119,
                    "end": 122,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 123,
                    "end": 126,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 127,
                    "end": 130,
                    "text": "[5]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 131,
                    "end": 134,
                    "text": "[6]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 135,
                    "end": 138,
                    "text": "[7]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 139,
                    "end": 142,
                    "text": "[8]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 145,
                    "end": 153,
                    "text": "Koslicki",
                    "ref_id": null
                },
                {
                    "start": 154,
                    "end": 157,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 488,
                    "end": 491,
                    "text": "[7]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 637,
                    "end": 640,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 782,
                    "end": 785,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we propose a new method for calculating sequences different from other traditional methods. It holds not only statistical values but also structural information. We replace four nucleotides with tree structure presented in [9] and use mathematical tools to calculate complexity values of the sequences. So we can compare two sequences with values and determine dissimilarity between these two sequences. In biomedical section, we can use this technique to find the effective drugs for new virus with priority.",
            "cite_spans": [
                {
                    "start": 238,
                    "end": 241,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our method uses Lindenmayer system [10] [11] [12] property among calculated complexities from tree structure [9] ; it is a different way of computing complexities of sequences. At first, we introduce DNA tree and convert DNA sequence to tree structure. A DNA tree is a binary tree of which each subtree is also a DNA tree. Every tree node is either a terminal node or a node with two childrens (branches or descendants). Lindenmayer system is a powerful rewriting system used to model the growth processes of plant development. We will introduce it in Section 2.2 in detail. Lindenmayer system uses some initial and rewriting rules to construct beautiful graphs. Since it can construct a tree from rewriting rules, it also can extract rewriting rules from a tree. In this section, we will use tools to generate the rules from tree.",
            "cite_spans": [
                {
                    "start": 35,
                    "end": 39,
                    "text": "[10]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 40,
                    "end": 44,
                    "text": "[11]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 45,
                    "end": 49,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 109,
                    "end": 112,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "DNA Sequence Represented with Tree Structure"
        },
        {
            "text": "We use 4 fixed tree representations for nucleotide bases A, T, C, and G (see Figure 1 ). When we apply this method to amino acid sequence, we can construct more tree representation for amino acids, respectively.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 77,
                    "end": 85,
                    "text": "Figure 1",
                    "ref_id": "FIGREF10"
                }
            ],
            "section": "DNA Sequence Represented with Tree Structure"
        },
        {
            "text": "When we transfer a sequence to DNA tree, we will replace every word to tree elements step by step, and two consecutive trees can combine to a bigger tree. Following the previous steps, a DNA sequence will be transfer to a DNA tree (see Figure 2 ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 236,
                    "end": 244,
                    "text": "Figure 2",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "DNA Sequence Represented with Tree Structure"
        },
        {
            "text": "For computing complexity of our DNA tree, we need some rules for converting tree to another structure. We use a stack similarly structure to represent the hierarchy of DNA tree, called bracketed string. DNA tree can transfer to a unique bracketed string by the following symbols, and it can transfer back to the original tree:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "(i) : the current location of tree nodes; it can be replaced by any word or be omitted;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "(ii) +: the following string will express the right subtree;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "(iii) \u2212: the following string will express the left subtree;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "(iv) [: this symbol is pairing with ]; \"[\u22c5 \u22c5 \u22c5]\" denotes a subtree where \"\u22c5 \u22c5 \u22c5\"; indicates all the bracketed strings of its subtree;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "(v) ]: see [ description.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "Following the previous symbols, Figure 3 shows And Figure 4 is the bracketed string of Figure 2 . We can see that when the tree grows, string seems to be more redundant. Since we focus here only on DNA trees, we can simplify the bracketed string representations. First, our trees have only two subtrees. Second, the \" \" notation for the tree is trivial. With these two characteristics, we may omit the \" \" notation from the bracketed string and use only four symbols, {[, ], \u2212, +}, to represent trees. In our cases, \"[\u22c5 \u22c5 \u22c5]\" denotes a subtree where \"\u22c5 \u22c5 \u22c5\" indicates all the bracketed strings of its subtrees. \"\u2212\" indicated the next \"[\u22c5 \u22c5 \u22c5]\" notation for a tree is a left subtree of current node, and \"+\" is a right subtree vice versa. Figure 5 is the simplified string of bracketed string shown in Figure 4 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 32,
                    "end": 40,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 51,
                    "end": 59,
                    "text": "Figure 4",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 87,
                    "end": 95,
                    "text": "Figure 2",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 738,
                    "end": 746,
                    "text": "Figure 5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 801,
                    "end": 809,
                    "text": "Figure 4",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Bracketed Strings for a DNA Sequence."
        },
        {
            "text": "When we obtain DNA tree and bracketed string representation, we need rewriting rules for analyzing tree structure. There are some types of rewriting mechanism such as Chomsky grammar and Lindenmayer system (L-system for short). The largest difference between two string rewriting mechanisms lies in the technique used to apply productions. Chomsky grammar is suitable for applying productions sequentially, while Lsystem is for parallel. In our structure, applying L-system to our representations is better than Chomsky grammar. The L-system was introduced by the biologist Lindenmayer in 1968 [13] . The central concept of the L-system is rewriting. In general, rewriting is a technique used to define complex objects by successively replacing parts of a simple initial object, using a set of rewriting rules or productions. In the next section, we will present how we use L-system to our DNA tree. The L-system is defined as follows.",
            "cite_spans": [
                {
                    "start": 594,
                    "end": 598,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "DNA Sequence Represented with L-System."
        },
        {
            "text": "Definition 1. L-system grammars are very similar to the Chomsky grammar, defined as a tuple [14] :",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 96,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "DNA Sequence Represented with L-System."
        },
        {
            "text": "where (i) = { 1 , 2 , . . . , } is an alphabet, (ii) (start, axiom, or initiator) is a string of symbols from defining the initial state of the system, (iii) is defined by a production map : \u2192 * with \u2192 ( ) for each in . The identity production \u2192 is assumed. These symbols are called constants or terminals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Represented with L-System."
        },
        {
            "text": "As discussed earlier, we want to generate the rules from DNA trees. In this section, Computational and Mathematical Methods in Medicine we will explain how we apply rewriting rules to those trees. We can apply distinct variables to each node. Since the technique described previously always generates two subtrees for each node, for every nonterminal node, they always can be explained in the following format:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Rewriting Rules for DNA Sequences."
        },
        {
            "text": "where denotes the current node, denotes its left subtree, and denotes its right subtree, respectively. We give an example shown in Figure 6 ; left tree has three nodes and only root is nonterminal node, it can be rewritten as \u2192 . Right tree has five nodes, root with left subtree and right subtree . Left subtree is terminal, but right is not. has two terminal subtrees and , so this tree can be rewritten as \u2192 and \u2192 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 131,
                    "end": 139,
                    "text": "Figure 6",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Rewriting Rules for DNA Sequences."
        },
        {
            "text": "Similarly, we can also use rewriting rules to generate bracketed strings. In rewriting rules for DNA trees shown in Section 2.3, we write \u2192 for a tree with left and right subtrees. Note that we call and as the nonterminals. In this section, terminal nodes will be separated from trees, and we use \"null\" to represent a terminal. Such tree will have a corresponding bracketed string as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": "represents the left subtree, while \"[+ \u22c5 \u22c5 \u22c5]\" represents the right subtree. Therefore, we can replace the rewriting rules with",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": "where \"\u22c5 \u22c5 \u22c5\" is the rewriting rule for the bracketed string of each subtree. For the sake of readability, we replace the words such as \" \" and \" \". In Figure 7 , we show the rewriting rules for the bracketed string of the tree in Figure 3 . As we can see, there are \"nulls\" in the rules. Those \"nulls\" do not have significant effects to our algorithm, so we simply ignore the nulls. Now, Figure 3 can apply new rewriting rules without trivial nulls as Figure 8 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 152,
                    "end": 160,
                    "text": "Figure 7",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 231,
                    "end": 239,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 389,
                    "end": 397,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 453,
                    "end": 461,
                    "text": "Figure 8",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": "When tree grows up, the rewriting rules may generate identical rules. Assume that we have the following rules:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": "These rules can generate exactly one bracketed string and, thus, exactly one DNA tree. All these rules form a rule set that represents a unique DNA tree. When we look at",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": ", they have the same structure since they both have a right subtree and do not have a left subtree. The only difference is that one of the subtrees is and that the other is . We will define two terms to 4",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": "Computational and Mathematical Methods in Medicine express the similarity between two rewriting rules, and these terms can simplify complexity analysis. [9] gave two definitions to classify similar rewriting rules described before as follows.",
            "cite_spans": [
                {
                    "start": 153,
                    "end": 156,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Rewriting Rules for Bracketed Strings."
        },
        {
            "text": "Definition 2. Homomorphism in rewriting rules. We define that rewriting rule 1 and rewriting rule 2 are homomorphic to each other if and only if they have the same structure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Homomorphism and"
        },
        {
            "text": "In detail, rewriting rule 1 and rewriting rule 2 in DNA trees both have subtrees in corresponding positions or both not. Ignoring all nonterminals, if rule 1 and rule 2 generate the same bracketed string, then they are homomorphic by definition. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Homomorphism and"
        },
        {
            "text": "We find that , , , and are homomorphic to each other; they generate the same bracketed string,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Homomorphism and"
        },
        {
            "text": "is not homomorphic to any of the other rules; its bracketed string is [\u2212 ].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Homomorphism and"
        },
        {
            "text": "Let us recall DNA tree example in Figure 2 ; we will use this figure as an example to clarify these definitions. Now we marked some nodes shown in Figure 9 ; there are tree rooted at A, B, C, and D, respectively, tree A, tree B, tree C, and tree D. Tree A is isomorphic to tree C on depth 0 to 3, but they are not isomorphic on depth 4. Tree B is isomorphic to tree C on depth from 0 to 2, but they are not isomorphic on depth 3. D is not isomorphic to any other trees, nor is it homomorphic to any other trees.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 34,
                    "end": 42,
                    "text": "Figure 2",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 147,
                    "end": 155,
                    "text": "Figure 9",
                    "ref_id": null
                }
            ],
            "section": "Homomorphism and"
        },
        {
            "text": "After we define the similarity between rules by homomorphism and isomorphism, we can classify all the rules into different subsets, and every subset has the same similarity relation. Now we list all the rewriting rules of Figure 2 into Table 1 but ignore terminal rules such as \" \u2192 null\" and transfer rule's name to class name (or class number). For example, we can give terminal rewriting rule a class, \" 3 \u2192 null\", and a rule link to two terminals; we can give them \" 2 \u2192 3 3 \"; here 3 is the terminal class. After performing classification, we obtain not only a new rewriting rule set but also a context-free grammar, which can be converted to automata.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 222,
                    "end": 230,
                    "text": "Figure 2",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 236,
                    "end": 243,
                    "text": "Table 1",
                    "ref_id": "TABREF3"
                }
            ],
            "section": "Homomorphism and"
        },
        {
            "text": "In Table 1 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 10,
                    "text": "Table 1",
                    "ref_id": "TABREF3"
                }
            ],
            "section": "Homomorphism and"
        },
        {
            "text": "When we transfer the DNA sequence to the rewriting rules, and classify all those rules we attempt to explore the redundancy in the tree that will be the base for building the cognitive map [15] . We compute the complexity of the tree which those classified rules represent. We know that a classified rewriting rule set is also a context-free grammar, so there are some methods for computing complexity of rewriting rule as follows.",
            "cite_spans": [
                {
                    "start": 189,
                    "end": 193,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "Definition 4. Topological entropy of a context-free grammar. The topological entropy 0 of (context-free grammar) CFG can be evaluated by means of the following three procedures [16, 17] .",
            "cite_spans": [
                {
                    "start": 177,
                    "end": 181,
                    "text": "[16,",
                    "ref_id": null
                },
                {
                    "start": 182,
                    "end": 185,
                    "text": "17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "Computational and Mathematical Methods in Medicine 5 (1) For each variable with productions (in Greibach form),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "where { 1 , 2 , . . . , , } are terminals and { 1 , 2 , . . . , , } are nonterminals. The formal algebraic expression for each variable is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "(2) By replacing every terminal with an auxiliary variable , one obtains the generating function",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "where ( ) is the number of words of length descending from .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "(3) Let ( ) be the largest one of ( ), ( ) = max{ ( ), for all }. The previous series converges ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "Class #4 (20) 4 \u2192 5 5 (1) 4 \u2192 9 11",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "(1) 4 \u2192 12 10",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "Class #5 (48) 5 \u2192 null (1) 5 \u2192 10 8 (1) 5 \u2192 13 11",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DNA Sequence Complexity"
        },
        {
            "text": "(1) 6 \u2192 10 10 (1) 6 \u2192 13 13",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #6"
        },
        {
            "text": "(1) 7 \u2192 11 9",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "(1) 7 \u2192 13 15 Class #8 (5) 8 \u2192 11 11 (1) 8 \u2192 14 14 Class #9 (4) 9 \u2192 11 12 (1) 9 \u2192 14 16 Class #10 (4) 10 \u2192 12 11 (1) 10 \u2192 15 13 Class #11 (20) 11 \u2192 12 12 (1) 11 \u2192 15 15 Class #12 (48) 12 \u2192 null (1) 12 \u2192 16 14 Class #13 (5) 13 \u2192 16 16 Class #14 (4) 14 \u2192 16 17 Class #15 (4) 15 \u2192 17 16 Class #16 (20) 16 \u2192 17 17 Class #17 (48) 17 \u2192 null when < = \u2212 0 . The topological entropy is given by the radius of convergence as",
            "cite_spans": [
                {
                    "start": 8,
                    "end": 13,
                    "text": "13 15",
                    "ref_id": null
                },
                {
                    "start": 34,
                    "end": 36,
                    "text": "11",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 45,
                    "end": 50,
                    "text": "14 14",
                    "ref_id": null
                },
                {
                    "start": 82,
                    "end": 87,
                    "text": "14 16",
                    "ref_id": null
                },
                {
                    "start": 110,
                    "end": 112,
                    "text": "11",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 122,
                    "end": 127,
                    "text": "15 13",
                    "ref_id": null
                },
                {
                    "start": 163,
                    "end": 168,
                    "text": "15 15",
                    "ref_id": null
                },
                {
                    "start": 203,
                    "end": 208,
                    "text": "16 14",
                    "ref_id": null
                },
                {
                    "start": 228,
                    "end": 233,
                    "text": "16 16",
                    "ref_id": null
                },
                {
                    "start": 253,
                    "end": 258,
                    "text": "16 17",
                    "ref_id": null
                },
                {
                    "start": 278,
                    "end": 283,
                    "text": "17 16",
                    "ref_id": null
                },
                {
                    "start": 299,
                    "end": 301,
                    "text": "16",
                    "ref_id": null
                },
                {
                    "start": 304,
                    "end": 309,
                    "text": "17 17",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "Our productions have some difference from the aforementioned definitions. First, our productions are written in Chomsky-reduced form instead of Greibach form. Second, DNA is finite sequence; it generates finite tree, but the previous formulas are applied on infinite sequences. For convenience in the DNA tree case, we rewrite the definition as follows [9] . ",
            "cite_spans": [
                {
                    "start": 353,
                    "end": 356,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "(2) The generating function of , ( ) has a new form as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "If does not have any nonterminal variables, we set ( ) = 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "(3) After formulating the generating function ( ), we intend to find the largest value of , max , at which rule for the root node of the DNA tree. After obtaining the largest value, max , of 1 ( ), we set = max , the radius of convergence of 1 ( ). We define the complexity of the DNA tree as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "Now we can do some examples of computation procedure for the complexity. According to our definition, the given values for the class parameters are listed in Table 3 . There are five classes, so we obtain the formulas for 5 ( ), 4 ( ), 3 ( ), 2 ( ), and 1 ( ) successively. They are",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 158,
                    "end": 165,
                    "text": "Table 3",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Class #7"
        },
        {
            "text": "19 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "Rearranging the previous equation for 1 ( ), we obtain a quadratic for 1 ( ):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "Solving 1 ( ), we obtain the formula where = 32 361 (2( ) 6 + 2( ) 5 + 5( ) 4 ) , Finally, the radius of convergence, , and complexity, 0 = \u2212ln , can be obtained from this formula. But, computing the max directly is difficult, so we use iterations and region tests to approximate the complexity; details are as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "(1) Rewrite the generating function as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "(2) The value from 0 ( ) to ( ). When \u22121 ( ) = ( ) for all rules, we say that ( ) reach the convergence, but is not the max we want. Here, we set = 1000 for each iteration.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "(3) Now we can test whether ( ) is convergent or divergent at a number . We use binary search to test every real number between 0 and 1; in every test, when ( ) converges, we set bigger next time, but when ( ) diverges, we set smaller next time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "Running more iterations will obtain more precise radius.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Class #7"
        },
        {
            "text": "In 2011, Koslicki [1] gave an efficient way to compute the topological entropy of DNA sequence. He used fixed length depending on subword size to compute topological entropy of sequence. For example, in Figure 10 (all DNA and amino acid data can be found in NCBI website, http://www.ncbi.nlm.nih.gov/), the sequence length is 1027 characters, and there are three subword sizes 2, 3, and 4 with blue, red, and green lines, respectively. For larger subword size, much larger fragment is required for complexity computation. The required fragment size grows exponentially, while the length of sequence is not dependent on the growth rate of subword size, so it is not a good method for us overall. We present a new method called structural complexity in previous sections, and there are several benefits from using our method instead of Koslicki method, described as follows. (2) Two different characters that exchange position will change value since Koslicki method just calculates the statistical values without structural information.",
            "cite_spans": [
                {
                    "start": 18,
                    "end": 21,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 203,
                    "end": 212,
                    "text": "Figure 10",
                    "ref_id": "FIGREF10"
                }
            ],
            "section": "Results"
        },
        {
            "text": "Result was shown in Figure 11 bottom chart; the test sequence repeats the same subword several times. For blue line, all complexity values from topological entropy are equal within the region of repeated subwords. For red line, complexity values depend on the structure of subword. When the fragment of sequence is different from each other, our method will evaluate to different values.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 20,
                    "end": 29,
                    "text": "Figure 11",
                    "ref_id": "FIGREF10"
                }
            ],
            "section": "Results"
        },
        {
            "text": "(3) Our method can also calculate amino acid sequences. The Koslicki method depends on alphabet size and subword size, for example, in the basic length 2 substring calculation; since standard amino acid types have up to 20, it requires a minimum length of 20 2 + 2\u22121 to calculate, but the amino acid strings are usually very short. Sometimes, Koslicki method cannot compute the amino acid sequence efficiently. Figure 12 shows that complexity of amino acid sequence can also be calculated by our method.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 411,
                    "end": 420,
                    "text": "Figure 12",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Results"
        },
        {
            "text": "We also did experiments with lots of data, including fixed fragment size and fixed method on test sequences (see Figures 13 and 14) . Here, we redefine the Koslicki method; the fragment size is no longer dependent on subword size. Instead, fixed length fragment like our method is applied. This change allows us to compare the data easier, and not restricted to the exponentially growing fragment size anymore. In Figure 13 , we found that for larger fragment, the complexity curve will become smoothly because fragments for each data point contain more information. And we note that there is a common local peak value of those figures; the simple sequence region is big enough that our fragment size still contains the same simple sequence.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 113,
                    "end": 131,
                    "text": "Figures 13 and 14)",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 414,
                    "end": 423,
                    "text": "Figure 13",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Results"
        },
        {
            "text": "When we compare with the same method shown in Figure 14 , we found the same situation more obviously. Thus, if we have many complexity values with different sizes, we have the opportunity to restore the portion of the DNA.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 46,
                    "end": 55,
                    "text": "Figure 14",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Results"
        },
        {
            "text": "Sequences. Now we can apply our technique to Chinese word sequences. Togawa et al. [18] gave a complexity of Chinese words, but his study was based on the number of strokes, which is different from our method. Here we use Big5 encoding for our system. Since the number of Chinese words is larger than 10000, we cannot directly use words as alphabet, so we need some conversion. We read a Chinese word into four hexadecimal letters so that we can replace the sequence with tree representation and compute the complexity. When it comes to biomedical section, we can create virus comparison database. Once a new virus or prion has been found, it will be easy to select corresponding drugs at the first time, according to cross comparison with each other by complexity in the database. We focus on most important viruses in recent years, such as Escherichia coli O157:H7 (E. coli o157), Enterovirus 71 (EV71), Influenza A virus subtype H1N1 (H1N1), Influenza A virus subtype H5N1 (H5N1), and severe acute respiratory syndrome (SARS). In recent years, these viruses have a significant impact and threat on the human world. We test these viruses and prions listed in Table 4 . Here we can see that all prion regions cannot be analyzed by Koslicki method, but we can do it.",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [
                {
                    "start": 1161,
                    "end": 1168,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "Application to Virus Sequences Database and Other"
        },
        {
            "text": "Finally, if any object can be written as a sequence, and there exists tree representation with alphabet of sequence, we can compute the complexity of the object.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Virus Sequences Database and Other"
        },
        {
            "text": "In this paper, we give a method for computing complexity of DNA sequences. The traditional method focused on the statistical data or simply explored the structural complexity without value. In our method, we transform the DNA sequence to DNA tree with tree representations at first.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Summary"
        },
        {
            "text": "Then we transform the tree to context-free grammar format, so that it can be classified. Finally, we use redefined generating function and find the complexity values. We give a not only statistical but also structural complexity for DNA sequences, and this technique can be used in many important applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Summary"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Topological entropy of DNA sequences",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Koslicki",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Article ID btr077",
            "volume": "27",
            "issn": "",
            "pages": "1061--1067",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Entropy and multifractality for the myeloma multiple tet 2 gene",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cattani",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Altieri",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Mathematical Problems in Engineering",
            "volume": "2012",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Reverse engineering approach in molecular evolution: simulation and case study with enzyme proteins",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Manna",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "Y"
                    ],
                    "last": "Liou",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the International Conference on Bioinformatics & Computational Biology (BIOCOMP '06)",
            "volume": "",
            "issn": "",
            "pages": "529--533",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Z curves, an intutive tool for visualizing and analyzing the DNA sequences",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "T"
                    ],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Spatial representation of symbolic sequences through iterative function systems",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ti\u00f1o",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "IEEE Transactions on Systems, Man, and Cybernetics A",
            "volume": "29",
            "issn": "4",
            "pages": "386--393",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Long-range correlations in nucleotide sequences",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "K"
                    ],
                    "last": "Peng",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "V"
                    ],
                    "last": "Buldyrev",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "L"
                    ],
                    "last": "Goldberger",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Nature",
            "volume": "356",
            "issn": "6365",
            "pages": "168--170",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Fractals related to long DNA sequences and complete genomes",
            "authors": [
                {
                    "first": "B",
                    "middle": [
                        "L"
                    ],
                    "last": "Hao",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "C"
                    ],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "Y"
                    ],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Chaos, solitons and fractals",
            "volume": "11",
            "issn": "6",
            "pages": "825--836",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Fractals and hidden symmetries in DNA",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cattani",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Mathematical Problems in Engineering",
            "volume": "2010",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Modeling complexity in musical rhythm",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "Y"
                    ],
                    "last": "Liou",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "H"
                    ],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "Y"
                    ],
                    "last": "Lee",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Complexity",
            "volume": "15",
            "issn": "4",
            "pages": "19--30",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Score generation with lsystems",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Prusinkiewicz",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "Proceedings of the International Computer Music Conference",
            "volume": "",
            "issn": "",
            "pages": "455--457",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The Algorithmic Beauty of Plants",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Prusinkiewicz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lindenmayer",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Growing music: musical interpretations of L-systems",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Worth",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Stepney",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Applications of Evolutionary Computing",
            "volume": "3449",
            "issn": "",
            "pages": "545--550",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Mathematical models for cellular interactions in development II",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lindenmayer",
                    "suffix": ""
                }
            ],
            "year": 1968,
            "venue": "Journal of Theoretical Biology",
            "volume": "18",
            "issn": "3",
            "pages": "300--315",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Wikipedia: L-system-Wikipedia, the free encyclopedia",
            "authors": [],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Unsupervised learning",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Barlow",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Neural Computation",
            "volume": "1",
            "issn": "3",
            "pages": "295--311",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "On the entropy of context-free languages",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Kuich",
                    "suffix": ""
                }
            ],
            "year": 1970,
            "venue": "Information and Control",
            "volume": "16",
            "issn": "2",
            "pages": "173--200",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Complexity of chinese characters",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Togawa",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Otsuka",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hiki",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kitaoka",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Forma",
            "volume": "15",
            "issn": "",
            "pages": "409--414",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "DNA sequence represented with tree structure.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Bracketed strings representation for two trees.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Bracketed strings representation for Figure 2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "More simply bracketed strings representation for Figure 2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Example of rewriting rules for trees.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Rewriting rules for the bracketed string of trees.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Rewriting rules for the bracketed string without nulls of trees.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Isomorphism on level in rewriting rules. Rewriting rule 1 and rewriting rule 2 are isomorphic on depth if they are homomorphic and their nonterminals are relatively isomorphic on depth \u2212 1. Isomorphic on level 0 indicates homomorphism. Applying to the bracketed string, we ignore all nonterminals in (4) as follows: \u2192 [\u2212 ] [+ ] \u2192 [\u2212 ] [+ ] , \u2192 [\u2212 ] [+ ] \u2192 [\u2212 ] [+ ] ,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Topological entropy of context free grammar for DNA tree.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Assume that there are classes of rules and that each class contains rules. Let \u2208 { 1 , 2 , . . . , }, \u2208 { , = 1, 2, . . . , , = 1, 2, . . . , }, and \u2208 { : = 1, 2, . . . , },",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Example Koslicki method (topological entropy method, TE for short) example.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Our method compared with TE using test sequences. An amino acid sequence example, Bovine spongiform encephalopathy.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "Our results are very different from those obtained by the topological entropy method; see the colored lines inFigures 11\u223c14. These figures showed that our method is much sensitive to certain arrangements of the elements in the sequence. Compare with different methods.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF14": {
            "text": "Compare with different fragment sizes.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "that nucleotide base A and T represented tree can transfer to [ [\u2212 ][+ ]] and [ [\u2212 ][+ [\u2212 ][+ ]]], respectively.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Isomorphism of Rewriting Rules. At the end of the previous section, we discussed that \u2192 [\u2212 ][+ ] and \u2192 [\u2212 ][+ ] are almost the same. How can we summarize or organize an effective feature to them? Liou et al.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Rewriting rules for the DNA tree inFigure 2.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "Continued.",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "Classification based on the similarity of rewriting rules.",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "The values for the class parameters ofTable 2.",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Test data with topological entropy method and our method.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "This work was supported by the National Science Council under project NSC 100-2221-E-002-234-MY3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgment"
        }
    ]
}